use crate::*;

/// Events to be generated by the contract according to NEP-297

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupNew {
    pub token_account_id: AccountId,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupAddToDepositWhitelist {
    pub account_ids: Vec<AccountId>,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupRemoveFromDepositWhitelist {
    pub account_ids: Vec<AccountId>,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupAddToDraftOperatorsWhitelist {
    pub account_ids: Vec<AccountId>,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupRemoveFromDraftOperatorsWhitelist {
    pub account_ids: Vec<AccountId>,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupCreateLockup {
    pub id: LockupIndex,
    pub account_id: AccountId,
    pub balance: WrappedBalance,
    pub start: TimestampSec,
    pub finish: TimestampSec,
    pub terminatable: bool,
    pub draft_id: Option<DraftIndex>,
}

impl From<(LockupIndex, Lockup, Option<DraftIndex>)> for FtLockupCreateLockup {
    fn from(tuple: (LockupIndex, Lockup, Option<DraftIndex>)) -> Self {
        let (id, lockup, draft_id) = tuple;
        Self {
            id,
            account_id: lockup.account_id.to_string(),
            balance: lockup.schedule.total_balance().into(),
            start: lockup.schedule.0.first().unwrap().timestamp,
            finish: lockup.schedule.0.last().unwrap().timestamp,
            terminatable: lockup.termination_config.is_some(),
            draft_id,
        }
    }
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupClaimLockup {
    pub id: LockupIndex,
    pub amount: WrappedBalance,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupTerminateLockup {
    pub id: LockupIndex,
    pub termination_timestamp: TimestampSec,
    pub unvested_balance: WrappedBalance,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupCreateDraftGroup {
    pub id: DraftGroupIndex,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupCreateDraft {
    pub id: DraftIndex,
    pub draft_group_id: DraftGroupIndex,
    pub account_id: AccountId,
    pub balance: WrappedBalance,
    pub start: TimestampSec,
    pub finish: TimestampSec,
    pub terminatable: bool,
}

impl From<(DraftIndex, Draft)> for FtLockupCreateDraft {
    fn from(tuple: (DraftIndex, Draft)) -> Self {
        let (id, draft) = tuple;
        Self {
            id,
            draft_group_id: draft.draft_group_id,
            account_id: draft.lockup_create.account_id.to_string(),
            balance: draft.lockup_create.schedule.total_balance().into(),
            start: draft.lockup_create.schedule.0.first().unwrap().timestamp,
            finish: draft.lockup_create.schedule.0.last().unwrap().timestamp,
            terminatable: draft.lockup_create.vesting_schedule.is_some(),
        }
    }
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupFundDraftGroup {
    pub id: DraftGroupIndex,
    pub amount: WrappedBalance,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupDiscardDraftGroup {
    pub id: DraftGroupIndex,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupDeleteDraft {
    pub id: DraftIndex,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
pub(crate) enum EventKind {
    FtLockupNew(FtLockupNew),
    FtLockupAddToDepositWhitelist(FtLockupAddToDepositWhitelist),
    FtLockupRemoveFromDepositWhitelist(FtLockupRemoveFromDepositWhitelist),
    FtLockupAddToDraftOperatorsWhitelist(FtLockupAddToDraftOperatorsWhitelist),
    FtLockupRemoveFromDraftOperatorsWhitelist(FtLockupRemoveFromDraftOperatorsWhitelist),
    FtLockupCreateLockup(Vec<FtLockupCreateLockup>),
    FtLockupClaimLockup(Vec<FtLockupClaimLockup>),
    FtLockupTerminateLockup(Vec<FtLockupTerminateLockup>),
    FtLockupCreateDraftGroup(Vec<FtLockupCreateDraftGroup>),
    FtLockupCreateDraft(Vec<FtLockupCreateDraft>),
    FtLockupFundDraftGroup(Vec<FtLockupFundDraftGroup>),
    FtLockupDiscardDraftGroup(Vec<FtLockupDiscardDraftGroup>),
    FtLockupDeleteDraft(Vec<FtLockupDeleteDraft>),
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(rename_all = "snake_case")]
pub(crate) struct NearEvent {
    standard: String,
    version: String,
    #[serde(flatten)]
    event_kind: EventKind,
}

impl From<EventKind> for NearEvent {
    fn from(event_kind: EventKind) -> Self {
        Self {
            standard: PACKAGE_NAME.into(),
            version: VERSION.into(),
            event_kind,
        }
    }
}

impl NearEvent {
    fn to_json_string(&self) -> String {
        serde_json::to_string(self).unwrap()
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    pub(crate) fn emit(self) {
        log!("{}", &self.to_json_event_string());
    }
}

pub(crate) fn emit(event_kind: EventKind) {
    NearEvent::from(event_kind).emit();
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::serde_json::json;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{test_utils, testing_env, MockedBlockchain, VMContext};

    pub fn get_context() -> VMContext {
        VMContextBuilder::new().is_view(true).build()
    }

    #[test]
    fn test_ft_lockup_init() {
        testing_env!(get_context());

        let token_account_id = "token.near".into();
        emit(EventKind::FtLockupNew(FtLockupNew { token_account_id }));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_new",
                    "data": { "token_account_id": "token.near" },
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_add_to_deposit_whitelist() {
        testing_env!(get_context());

        let account_ids: Vec<AccountId> = vec!["alice.near", "bob.near"]
            .iter()
            .map(|&x| x.into())
            .collect();
        emit(EventKind::FtLockupAddToDepositWhitelist(
            FtLockupAddToDepositWhitelist { account_ids },
        ));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_add_to_deposit_whitelist",
                    "data": { "account_ids": ["alice.near", "bob.near"] },
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_remove_from_deposit_whitelist() {
        testing_env!(get_context());

        let account_ids: Vec<AccountId> = vec!["alice.near", "bob.near"]
            .iter()
            .map(|&x| x.into())
            .collect();
        emit(EventKind::FtLockupRemoveFromDepositWhitelist(
            FtLockupRemoveFromDepositWhitelist { account_ids },
        ));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_remove_from_deposit_whitelist",
                    "data": { "account_ids": ["alice.near", "bob.near"] },
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_add_to_draft_operators_whitelist() {
        testing_env!(get_context());

        let account_ids: Vec<AccountId> = vec!["alice.near", "bob.near"]
            .iter()
            .map(|&x| x.into())
            .collect();
        emit(EventKind::FtLockupAddToDraftOperatorsWhitelist(
            FtLockupAddToDraftOperatorsWhitelist { account_ids },
        ));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_add_to_draft_operators_whitelist",
                    "data": { "account_ids": ["alice.near", "bob.near"] },
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_remove_from_draft_operators_whitelist() {
        testing_env!(get_context());

        let account_ids: Vec<AccountId> = vec!["alice.near", "bob.near"]
            .iter()
            .map(|&x| x.into())
            .collect();
        emit(EventKind::FtLockupRemoveFromDraftOperatorsWhitelist(
            FtLockupRemoveFromDraftOperatorsWhitelist { account_ids },
        ));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_remove_from_draft_operators_whitelist",
                    "data": { "account_ids": ["alice.near", "bob.near"] },
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_create_lockup() {
        testing_env!(get_context());

        let account_id: AccountId = "alice.near".into();
        let balance: WrappedBalance = 10_000.into();
        let timestamp: TimestampSec = 1_500_000_000;
        let lockup = Lockup::new_unlocked_since(account_id.clone(), balance.0, timestamp);
        let lockup_id: LockupIndex = 100;
        let draft_id: DraftIndex = 33;

        let event: FtLockupCreateLockup = (100, lockup, Some(draft_id)).into();

        emit(EventKind::FtLockupCreateLockup(vec![event]));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_create_lockup",
                    "data": [
                        {
                            "id": lockup_id,
                            "account_id": account_id,
                            "balance": balance,
                            "start": timestamp - 1,
                            "finish": timestamp,
                            "terminatable": false,
                            "draft_id": Some(draft_id),
                        },
                    ],
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_claim_lockup() {
        testing_env!(get_context());

        let lockup_id: LockupIndex = 100;
        let amount: WrappedBalance = 10000.into();

        let event = FtLockupClaimLockup {
            id: lockup_id,
            amount,
        };

        emit(EventKind::FtLockupClaimLockup(vec![event]));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_claim_lockup",
                    "data": [
                        {
                            "id": lockup_id,
                            "amount": amount,
                        },
                    ],
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_terminate_lockup() {
        testing_env!(get_context());

        let lockup_id: LockupIndex = 100;
        let termination_timestamp: TimestampSec = 1_800_000_000;
        let unvested_balance: WrappedBalance = 10000.into();

        let event = FtLockupTerminateLockup {
            id: lockup_id,
            termination_timestamp,
            unvested_balance,
        };

        emit(EventKind::FtLockupTerminateLockup(vec![event]));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_terminate_lockup",
                    "data": [
                        {
                            "id": lockup_id,
                            "termination_timestamp": termination_timestamp,
                            "unvested_balance": unvested_balance,
                        },
                    ],
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_create_draft_group() {
        testing_env!(get_context());

        let draft_group_id: DraftGroupIndex = 22;

        let event = FtLockupCreateDraftGroup {
            id: draft_group_id,
        };

        emit(EventKind::FtLockupCreateDraftGroup(vec![event]));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_create_draft_group",
                    "data": [
                        {
                            "id": draft_group_id,
                        },
                    ],
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_create_draft() {
        testing_env!(get_context());

        let account_id: ValidAccountId = "alice.near".try_into().unwrap();
        let balance: WrappedBalance = 10_000.into();
        let timestamp: TimestampSec = 1_500_000_000;
        let lockup_create = LockupCreate {
            account_id: account_id.clone(),
            schedule: Schedule::new_unlocked_since(balance.0, timestamp),
            vesting_schedule: None,
        };
        let draft_group_id: DraftGroupIndex = 123;
        let draft = Draft { draft_group_id, lockup_create };
        let draft_id: DraftIndex = 33;

        let event: FtLockupCreateDraft = (draft_id, draft).into();

        emit(EventKind::FtLockupCreateDraft(vec![event]));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_create_draft",
                    "data": [
                        {
                            "id": draft_id,
                            "draft_group_id": draft_group_id,
                            "account_id": account_id.to_string(),
                            "balance": balance,
                            "start": timestamp - 1,
                            "finish": timestamp,
                            "terminatable": false,
                        },
                    ],
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_fund_draft_group() {
        testing_env!(get_context());

        let draft_group_id: DraftGroupIndex = 22;
        let amount: WrappedBalance = 10000.into();

        let event = FtLockupFundDraftGroup {
            id: draft_group_id,
            amount,
        };

        emit(EventKind::FtLockupFundDraftGroup(vec![event]));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_fund_draft_group",
                    "data": [
                        {
                            "id": draft_group_id,
                            "amount": amount,
                        },
                    ],
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_discard_draft_group() {
        testing_env!(get_context());

        let draft_group_id: DraftGroupIndex = 22;

        let event = FtLockupDiscardDraftGroup {
            id: draft_group_id,
        };

        emit(EventKind::FtLockupDiscardDraftGroup(vec![event]));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_discard_draft_group",
                    "data": [
                        {
                            "id": draft_group_id,
                        },
                    ],
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_delete_draft() {
        testing_env!(get_context());

        let draft_id: DraftIndex = 22;

        let event = FtLockupDeleteDraft {
            id: draft_id,
        };

        emit(EventKind::FtLockupDeleteDraft(vec![event]));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_delete_draft",
                    "data": [
                        {
                            "id": draft_id,
                        },
                    ],
                })
                .to_string(),
            )
        );
    }
}
