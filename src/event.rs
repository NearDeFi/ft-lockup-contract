use crate::*;

/// Events to be generated by the contract according to NEP-297

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupNew {
    pub token_account_id: AccountId,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupAddToDepositWhitelist {
    pub account_ids: Vec<AccountId>,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupRemoveFromDepositWhitelist {
    pub account_ids: Vec<AccountId>,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupAddToDraftOperatorsWhitelist {
    pub account_ids: Vec<AccountId>,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupRemoveFromDraftOperatorsWhitelist {
    pub account_ids: Vec<AccountId>,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FtLockupCreateLockup {
    pub id: LockupIndex,
    pub account_id: AccountId,
    pub balance: WrappedBalance,
    pub start: TimestampSec,
    pub finish: TimestampSec,
    pub terminatable: bool,
    pub draft_id: Option<DraftIndex>,
}

impl From<(LockupIndex, Lockup, Option<DraftIndex>)> for FtLockupCreateLockup {
    fn from(tuple: (LockupIndex, Lockup, Option<DraftIndex>)) -> Self {
        let (id, lockup, draft_id) = tuple;
        Self {
            id,
            account_id: lockup.account_id.to_string(),
            balance: lockup.schedule.total_balance().into(),
            start: lockup.schedule.0.first().unwrap().timestamp,
            finish: lockup.schedule.0.last().unwrap().timestamp,
            terminatable: lockup.termination_config.is_some(),
            draft_id,
        }
    }
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
pub(crate) enum EventKind {
    FtLockupNew(FtLockupNew),
    FtLockupAddToDepositWhitelist(FtLockupAddToDepositWhitelist),
    FtLockupRemoveFromDepositWhitelist(FtLockupRemoveFromDepositWhitelist),
    FtLockupAddToDraftOperatorsWhitelist(FtLockupAddToDraftOperatorsWhitelist),
    FtLockupRemoveFromDraftOperatorsWhitelist(FtLockupRemoveFromDraftOperatorsWhitelist),
    FtLockupCreateLockup(Vec<FtLockupCreateLockup>),
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(rename_all = "snake_case")]
pub(crate) struct NearEvent {
    standard: String,
    version: String,
    #[serde(flatten)]
    event_kind: EventKind,
}

impl From<EventKind> for NearEvent {
    fn from(event_kind: EventKind) -> Self {
        Self {
            standard: PACKAGE_NAME.into(),
            version: VERSION.into(),
            event_kind,
        }
    }
}

impl NearEvent {
    fn to_json_string(&self) -> String {
        serde_json::to_string(self).unwrap()
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    pub(crate) fn emit(self) {
        log!("{}", &self.to_json_event_string());
    }
}

pub(crate) fn emit(event_kind: EventKind) {
    NearEvent::from(event_kind).emit();
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::serde_json::json;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{test_utils, testing_env, MockedBlockchain, VMContext};

    pub fn get_context() -> VMContext {
        VMContextBuilder::new().is_view(true).build()
    }

    #[test]
    fn test_ft_lockup_init() {
        testing_env!(get_context());

        let token_account_id = "token.near".into();
        emit(EventKind::FtLockupNew(FtLockupNew { token_account_id }));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_new",
                    "data": { "token_account_id": "token.near" },
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_add_to_deposit_whitelist() {
        testing_env!(get_context());

        let account_ids: Vec<AccountId> = vec!["alice.near", "bob.near"]
            .iter()
            .map(|&x| x.into())
            .collect();
        emit(EventKind::FtLockupAddToDepositWhitelist(
            FtLockupAddToDepositWhitelist { account_ids },
        ));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_add_to_deposit_whitelist",
                    "data": { "account_ids": ["alice.near", "bob.near"] },
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_remove_from_deposit_whitelist() {
        testing_env!(get_context());

        let account_ids: Vec<AccountId> = vec!["alice.near", "bob.near"]
            .iter()
            .map(|&x| x.into())
            .collect();
        emit(EventKind::FtLockupRemoveFromDepositWhitelist(
            FtLockupRemoveFromDepositWhitelist { account_ids },
        ));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_remove_from_deposit_whitelist",
                    "data": { "account_ids": ["alice.near", "bob.near"] },
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_add_to_draft_operators_whitelist() {
        testing_env!(get_context());

        let account_ids: Vec<AccountId> = vec!["alice.near", "bob.near"]
            .iter()
            .map(|&x| x.into())
            .collect();
        emit(EventKind::FtLockupAddToDraftOperatorsWhitelist(
            FtLockupAddToDraftOperatorsWhitelist { account_ids },
        ));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_add_to_draft_operators_whitelist",
                    "data": { "account_ids": ["alice.near", "bob.near"] },
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_remove_from_draft_operators_whitelist() {
        testing_env!(get_context());

        let account_ids: Vec<AccountId> = vec!["alice.near", "bob.near"]
            .iter()
            .map(|&x| x.into())
            .collect();
        emit(EventKind::FtLockupRemoveFromDraftOperatorsWhitelist(
            FtLockupRemoveFromDraftOperatorsWhitelist { account_ids },
        ));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_remove_from_draft_operators_whitelist",
                    "data": { "account_ids": ["alice.near", "bob.near"] },
                })
                .to_string(),
            )
        );
    }

    #[test]
    fn test_ft_lockup_create_lockup() {
        testing_env!(get_context());

        let account_id: AccountId = "alice.near".into();
        let balance: WrappedBalance = 10_000.into();
        let timestamp: TimestampSec = 1_500_000_000;
        let lockup = Lockup::new_unlocked_since(account_id.clone(), balance.0, timestamp);
        let lockup_id: LockupIndex = 100;
        let draft_id: DraftIndex = 33;

        let event: FtLockupCreateLockup = (100, lockup, Some(draft_id)).into();

        emit(EventKind::FtLockupCreateLockup(vec![event]));
        assert_eq!(
            test_utils::get_logs()[0],
            format!(
                r"EVENT_JSON:{}",
                json!({
                    "standard": PACKAGE_NAME,
                    "version": VERSION,
                    "event": "ft_lockup_create_lockup",
                    "data": [
                        {
                            "id": lockup_id,
                            "account_id": account_id,
                            "balance": balance,
                            "start": timestamp - 1,
                            "finish": timestamp,
                            "terminatable": false,
                            "draft_id": Some(draft_id),
                        },
                    ],
                })
                .to_string(),
            )
        );
    }
}
